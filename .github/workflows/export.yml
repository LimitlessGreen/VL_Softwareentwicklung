name: Exporter

on:
  push:
    branches:
      - master
      - pdf_export
  workflow_dispatch:

permissions:
  contents: write # Für Releases

jobs:
  build_pdfs:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Wichtig für git log

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          # Kein npm-Cache, da wir keine package-lock.json haben

      # Cache für die generierten PDFs UND die Hash-Statusdatei
      # Der Key basiert auf dem Branch, damit Caches nicht zwischen Branches geteilt werden.
      # Restore-keys erlauben das Wiederherstellen eines älteren Caches, falls der exakte Key nicht passt.
      - name: Cache PDF Output und Build Hashes
        id: pdf-cache
        uses: actions/cache@v4
        with:
          path: |
            pdf_output/
            .pdf_build_hashes.json
          key: pdf-builds-${{ runner.os }}-${{ github.ref }}
          restore-keys: |
            pdf-builds-${{ runner.os }}-${{ github.ref }}- # Wichtig: Lädt den letzten Cache für diesen Branch

      - name: Install jq (if needed)
        run: |
          if ! command -v jq &> /dev/null
          then
              echo "jq could not be found, installing..."
              sudo apt-get update && sudo apt-get install -y jq
          else
              echo "jq is already installed."
          fi

      - name: Install LiaScript Exporter (liaex)
        run: npm install -g @liascript/exporter

      - name: Create PDF output directory
        run: mkdir -p pdf_output # Stellt sicher, dass das Verzeichnis existiert

      # --- PDF Konvertierung mit per-File Caching basierend auf Commit Hash ---
      - name: Convert Markdown to PDF with Per-File Commit Hash Caching
        id: convert
        run: |
          # Lade den Build-Status aus der JSON-Datei (falls vorhanden, sonst starte mit leerem Objekt)
          # Wenn der Cache wiederhergestellt wurde, existiert die Datei eventuell.
          if [ -f ".pdf_build_hashes.json" ]; then
            echo "Lade vorherigen Build-Status aus .pdf_build_hashes.json"
            # Stelle sicher, dass die Datei valides JSON enthält, sonst starte leer
            if jq empty .pdf_build_hashes.json > /dev/null 2>&1; then
               cp .pdf_build_hashes.json current_build_hashes.json
            else
               echo "Warnung: .pdf_build_hashes.json ist kein valides JSON. Starte mit leerem Status."
               echo "{}" > current_build_hashes.json
            fi
          else
            echo "Kein vorheriger Build-Status gefunden (.pdf_build_hashes.json). Starte mit leerem Status."
            echo "{}" > current_build_hashes.json
          fi

          # Finde alle Markdown-Dateien im Hauptverzeichnis
          find . -maxdepth 1 -name "*.md" -print0 | while IFS= read -r -d $'\0' file; do
            filename="${file#./}"
            echo "--- Processing: $filename ---"

            # Aktuellen Commit-Hash und Datum für die Datei ermitteln
            current_commit_hash=$(git log -1 --pretty="format:%H" -- "$filename")
            commit_date=$(git log -1 --pretty="format:%as" -- "$filename")
            if [ -z "$commit_date" ]; then # Fallback für Datum
              commit_date=$(date +%Y-%m-%d)
              echo "Warnung: Konnte keinen Commit für '$filename' finden, verwende aktuelles Datum."
              # Fallback für Hash (nicht ideal, aber nötig): Nimm den Hash des *Inhalts*
              current_commit_hash=$(git hash-object "$filename")
            fi

            # Zuletzt erfolgreich gebauten Hash aus dem Status lesen
            # jq -r gibt den rohen String ohne Anführungszeichen zurück, // "" als Fallback
            last_built_hash=$(jq -r --arg f "$filename" '.[$f] // ""' current_build_hashes.json)
            echo "Aktueller Commit-Hash für $filename: $current_commit_hash"
            echo "Zuletzt gebauter Hash für $filename: $last_built_hash"

            # Erwarteten PDF-Dateinamen konstruieren (ohne .pdf für liaex)
            base_name="${filename%.md}"
            safe_base_name=$(echo "$base_name" | sed 's/[^a-zA-Z0-9._-]/_/g')
            pdf_base_for_liaex="${safe_base_name}_${commit_date}"
            output_path_for_liaex="pdf_output/$pdf_base_for_liaex" # Für liaex --output
            final_pdf_filename="${pdf_base_for_liaex}.pdf"
            final_output_path="pdf_output/$final_pdf_filename"     # Erwarteter finaler Pfad

            build_needed=true # Annahme: Build ist nötig

            # Prüfen, ob ein Rebuild nötig ist
            if [ "$current_commit_hash" == "$last_built_hash" ]; then
              echo "Commit-Hash für $filename ist unverändert ($current_commit_hash)."
              # Prüfen, ob die Zieldatei existiert (aus dem Cache wiederhergestellt?)
              if [ -f "$final_output_path" ]; then
                echo "PDF '$final_output_path' existiert bereits (vermutlich aus Cache)."
                echo "--> Überspringe Build für $filename."
                build_needed=false
              else
                echo "PDF '$final_output_path' existiert NICHT, obwohl Hash gleich ist. Erzwinge Build."
              fi
            else
              echo "Commit-Hash für $filename hat sich geändert (alt: '$last_built_hash', neu: '$current_commit_hash'). Build ist nötig."
            fi

            # Nur bauen, wenn nötig
            if [ "$build_needed" = true ]; then
              echo "Starte Konvertierung für $filename nach $output_path_for_liaex..."
              # Konvertierung (Pfad ohne .pdf übergeben)
              liaex --input "$filename" --format pdf --output "$output_path_for_liaex" --pdf-timeout 60000

              if [ $? -eq 0 ]; then
                # Prüfen, ob die erwartete Datei erstellt wurde
                if [ -f "$final_output_path" ]; then
                  echo "Erfolgreich konvertiert: $filename zu $final_output_path"
                  # Aktualisiere den Status für diese Datei im JSON (nur bei Erfolg)
                  # Wir erstellen eine temporäre Datei, um Race Conditions beim Lesen/Schreiben zu vermeiden
                  jq --arg f "$filename" --arg h "$current_commit_hash" '. + {($f): $h}' current_build_hashes.json > tmp_hashes.json && mv tmp_hashes.json current_build_hashes.json
                  echo "Build-Status für $filename aktualisiert auf Hash $current_commit_hash."
                else
                  echo "::error::liaex meldete Erfolg für $filename, aber die erwartete Datei '$final_output_path' wurde nicht gefunden!"
                  # Status für diese Datei NICHT aktualisieren
                fi
              else
                echo "::error::Fehler bei der Konvertierung von $filename zu PDF mittels liaex."
                # Status für diese Datei NICHT aktualisieren
              fi
            fi
          done

          # Speichere den finalen Status (wird vom Cache-Schritt hochgeladen)
          echo "Speichere finalen Build-Status nach .pdf_build_hashes.json"
          cp current_build_hashes.json .pdf_build_hashes.json

      # --- Upload und Release Schritte bleiben wie zuvor ---

      # Upload als einzelnes Artefakt (optional, wenn Release verwendet wird)
      - name: Upload All PDFs as Single Artifact
        uses: actions/upload-artifact@v4
        with:
          name: liascript-pdfs-${{ github.sha }}
          path: pdf_output/
          if-no-files-found: warn # Fehler vermeiden, wenn keine PDFs gebaut wurden (sollte nicht passieren)

      # --- Schritt zum Ermitteln des aktuellen Datums und der Uhrzeit (Deutsches Format) ---
      - name: Aktuelles Datum und Uhrzeit ermitteln (Deutsch)
        id: datetime # Geänderte ID zur Klarheit
        run: echo "CURRENT_DATETIME=$(date +'%d.%m.%Y %H:%M:%S Uhr')" >> $GITHUB_ENV
        # Format: TT.MM.JJJJ HH:MM:SS Uhr (Verwendet die Zeitzone des Runners, oft UTC)

      # --- Schritt zum Ermitteln der Commit-Nachricht ---
      - name: Commit-Nachricht ermitteln
        id: commitmessage
        run: echo "COMMIT_MSG=$(git log -1 --pretty='format:%s' ${{ github.sha }})" >> $GITHUB_ENV
        # Holt die Betreffzeile (%s) des Commits

      # --- Automatisches Pre-Release erstellen/aktualisieren (auf Deutsch) ---
      - name: Pre-Release mit PDFs erstellen/aktualisieren (auf Deutsch)
        if: success() && github.ref == 'refs/heads/pdf_export' # Nur auf Master ausführen (oder anpassen)
        uses: softprops/action-gh-release@v2
        with:
          tag_name: latest-pdfs # Ein fester Tag für das "immer aktuelle" Pre-Release
          # Name des Releases auf Deutsch
          name: "Aktuellste PDF-Builds (${{ github.sha }})"
          # Body des Releases auf Deutsch, mit deutscher Zeit und Commit-Nachricht
          body: |
            Automatischer Build der PDF-Dokumente vom letzten Commit auf dem Branch '${{ github.ref_name }}'.

            Commit: ${{ github.sha }} (${{ env.COMMIT_MSG }})
            Datum: ${{ env.CURRENT_DATETIME }}

            Übersicht der Änderungen:
          prerelease: true # Als Pre-Release markieren
          draft: false # Nicht als Entwurf speichern
          files: pdf_output/*.pdf # Alle PDFs aus dem output Verzeichnis anhängen
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Token für API-Zugriff
