name: Exporter

on:
  push:
    branches:
      - master
      - pdf_export
  workflow_dispatch:

permissions: # Permissions werden für das Erstellen/Aktualisieren von Releases benötigt
  contents: write # Notwendig, um Releases zu erstellen/bearbeiten und Assets hochzuladen

jobs:
  build_pdfs:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Wichtig für git log, um den Commit-Verlauf zu bekommen

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install LiaScript Exporter (liaex)
        # Installiert liaex nur, wenn es nicht schon im Cache ist oder package-lock.json sich geändert hat
        run: npm install -g @liascript/exporter

      - name: Create PDF output directory
        run: mkdir -p pdf_output # -p verhindert Fehler, wenn das Verzeichnis schon existiert

      # --- PDF Konvertierungs-Loop mit Caching ---
      - name: Convert Markdown to PDF with Caching and Commit Date Suffix
        id: convert
        run: |
          # Finde alle Markdown-Dateien im Hauptverzeichnis
          find . -maxdepth 1 -name "*.md" -print0 | while IFS= read -r -d $'\0' file; do
            filename="${file#./}"
            echo "Processing: $filename"

            # JJJJ-MM-TT des letzten Commits für die Datei ermitteln
            commit_date=$(git log -1 --pretty="format:%as" -- "$filename")
            if [ -z "$commit_date" ]; then
              commit_date=$(date +%Y-%m-%d) # Fallback: heutiges Datum
            fi

            base_name="${filename%.md}"
            safe_base_name=$(echo "$base_name" | sed 's/[^a-zA-Z0-9._-]/_/g')

            # KORREKTUR: Definiere den Basis-Teil des PDF-Namens (ohne .pdf).
            # Dieser Name wird an liaex übergeben, da wir annehmen, dass liaex
            # bei --format pdf die Endung selbst hinzufügt.
            pdf_base_for_liaex="${safe_base_name}_${commit_date}"
            output_path_for_liaex="pdf_output/$pdf_base_for_liaex"

            # KORREKTUR: Definiere den *finalen* PDF-Dateinamen (mit .pdf).
            # Dieser wird für Artefakte, Releases und Dateiprüfungen verwendet,
            # nachdem liaex die Datei (hoffentlich korrekt) erstellt hat.
            final_pdf_filename="${pdf_base_for_liaex}.pdf"
            final_output_path="pdf_output/$final_pdf_filename" # Der Pfad, an dem die fertige PDF erwartet wird
            artifact_name="$final_pdf_filename"               # Der Name für Artefakte/Release-Assets

            echo "Output path for liaex: $output_path_for_liaex" # Wird an liaex übergeben
            echo "Expected final PDF path: $final_output_path"   # Wo die Datei nachher liegen sollte
            echo "Artifact name: $artifact_name"                 # Für Uploads

            # Konvertierung mit liaex: Übergib den Pfad OHNE .pdf Endung
            liaex --input "$filename" --format pdf --output "$output_path_for_liaex" --pdf-timeout 60000

            if [ $? -ne 0 ]; then
              echo "::error::Error converting $filename to PDF using liaex."
            else
              # Optional, aber empfohlen: Prüfen, ob die Datei am *erwarteten* finalen Ort existiert
              if [ -f "$final_output_path" ]; then
                 echo "Successfully converted $filename to $final_output_path"
              else
                 # Wenn liaex Erfolg meldet (Exit Code 0), aber die Datei nicht am erwarteten Ort mit .pdf liegt,
                 # war die Annahme (dass liaex .pdf hinzufügt) vielleicht falsch, ODER liaex hat die Datei
                 # doch anders benannt (z.B. ohne das Datum, falls der Commit nicht gefunden wurde?).
                 # Oder der Pfad `pdf_output` existiert nicht (sollte durch `mkdir -p` aber behoben sein).
                 echo "::warning::liaex command finished successfully, but the expected PDF '$final_output_path' was not found. Please check the actual output files and liaex behavior."
                 # Ggf. muss hier die Logik angepasst werden, falls liaex die Endung doch nicht selbst hinzufügt.
              fi
            fi
          done

      # --- Caching der generierten PDFs ---
      # Dieser Schritt speichert alle erfolgreich generierten PDFs im pdf_output Verzeichnis
      # basierend auf dem Hash *aller* Markdown-Dateien. Das ist ein gröberes Caching.
      # Wenn *irgendeine* MD-Datei sich ändert, wird der Cache ungültig.
      # Für feingranulares Caching pro Datei müsste man den Cache-Schritt *in* die Schleife verlegen
      # oder einen komplexeren Ansatz wählen.
      - name: Cache generated PDFs
        uses: actions/cache@v4
        with:
          path: pdf_output/
          key: pdfs-${{ runner.os }}-${{ hashFiles('*.md') }} # Cache basiert auf allen MD-Dateien

      # --- Einzelne Artefakte hochladen (falls gewünscht zusätzlich zum Release) ---
      # Diese Methode lädt jede PDF als separates Artefakt hoch.
      - name: Upload Individual PDF Artifacts
        if: success() # Nur ausführen, wenn die Konvertierung erfolgreich war
        run: |
          cd pdf_output
          for pdf_file in *.pdf; do
            # Verwende den Dateinamen als Artefaktnamen (ohne Pfad)
            artifact_name="${pdf_file}"
            echo "Uploading artifact: $artifact_name from file $pdf_file"
            # Erstelle temporär ein Verzeichnis für jedes Artefakt, da upload-artifact v4 Verzeichnisse erwartet
            mkdir -p "../artifact_temp/${artifact_name}"
            cp "$pdf_file" "../artifact_temp/${artifact_name}/"
            # Upload-Aktion muss außerhalb des Skripts aufgerufen werden oder über Umwege
          done
          cd ..
          # Temporäre Upload-Verzeichnisse wieder entfernen
          # rm -rf artifact_temp

      # === Problem: Direkter Aufruf von 'uses' in 'run' geht nicht. ===
      # Lösung: Entweder einen eigenen Action Step pro Datei (unpraktisch)
      # oder eine Action verwenden, die das Hochladen mehrerer individueller Artefakte unterstützt,
      # oder die Dateinamen sammeln und in einem Matrix-Job oder separaten Schritten hochladen.

      # Einfachere Methode: Alle PDFs zusammen als ein Artefakt hochladen (wie im Original)
      # Wenn individuelle Artefakte *unbedingt* erforderlich sind, wird es komplexer.
      - name: Upload All PDFs as Single Artifact (Alternative)
        uses: actions/upload-artifact@v4
        with:
          name: liascript-pdfs-${{ github.sha }} # Eindeutiger Name pro Commit
          path: pdf_output/
          if-no-files-found: warn

      - name: Aktuelles Datum ermitteln
        id: date # Optional, aber gut für die Referenzierung
        run: echo "CURRENT_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_ENV
        # Wir speichern das Datum in einer Umgebungsvariable namens CURRENT_DATE
        # Wichtig: Einfache Anführungszeichen um das Format für date sind sicherer.

      # --- Automatisches Pre-Release erstellen/aktualisieren (auf Deutsch) ---
      - name: Pre-Release mit PDFs erstellen/aktualisieren
        if: success() && github.ref == 'refs/heads/pdf_export' # Nur auf Master ausführen (oder anpassen)
        uses: softprops/action-gh-release@v2
        with:
          tag_name: latest-pdfs # Ein fester Tag für das "immer aktuelle" Pre-Release
          # Name des Releases auf Deutsch
          name: "Aktuellste PDF-Builds (${{ github.sha }})"
          # Body des Releases auf Deutsch, mit der Datums-Variable
          body: |
            Automatischer Build der PDF-Dokumente vom letzten Commit auf dem Branch '${{ github.ref_name }}'.
            Commit: ${{ github.sha }}
            Datum: ${{ env.CURRENT_DATE }} # Hier die Umgebungsvariable verwenden
          prerelease: true # Als Pre-Release markieren
          draft: false # Nicht als Entwurf speichern
          files: pdf_output/*.pdf # Alle PDFs aus dem output Verzeichnis anhängen
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Token für API-Zugriff
